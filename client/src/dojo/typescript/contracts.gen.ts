
// Generated by dojo-bindgen on Thu, 17 Oct 2024 00:58:56 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript` 
import { Account, byteArray } from "starknet";
import { DojoProvider } from "@dojoengine/core";
import * as models from "./models.gen";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
  // System definitions for `oz_token-actions` contract
  function actions() {
    const contract_name = "actions";


    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };



    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };



    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "spawn",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };



    // Call the `move` system with the specified Account and calldata
    const move = async (props: { account: Account, direction: models.Direction }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "move",
            calldata: [["None", "Left", "Right", "Up", "Down"].indexOf(props.direction.type)],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing move:", error);
        throw error;
      }
    };


    return {
      world, name, spawn, move
    };
  }

  // System definitions for `oz_token-cash` contract
  function cash() {
    const contract_name = "cash";


    // Call the `total_supply` system with the specified Account and calldata
    const total_supply = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "total_supply",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing total_supply:", error);
        throw error;
      }
    };



    // Call the `balance_of` system with the specified Account and calldata
    const balance_of = async (props: { account: Account, address: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "balance_of",
            calldata: [props.address],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing balance_of:", error);
        throw error;
      }
    };



    // Call the `allowance` system with the specified Account and calldata
    const allowance = async (props: { account: Account, owner: bigint, spender: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "allowance",
            calldata: [props.owner,
            props.spender],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing allowance:", error);
        throw error;
      }
    };



    // Call the `transfer` system with the specified Account and calldata
    const transfer = async (props: { account: Account, recipient: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transfer",
            calldata: [props.recipient,
            props.amount.low,
            props.amount.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing transfer:", error);
        throw error;
      }
    };



    // Call the `transfer_from` system with the specified Account and calldata
    const transfer_from = async (props: { account: Account, sender: bigint, recipient: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transfer_from",
            calldata: [props.sender,
            props.recipient,
            props.amount.low,
            props.amount.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing transfer_from:", error);
        throw error;
      }
    };



    // Call the `approve` system with the specified Account and calldata
    const approve = async (props: { account: Account, spender: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "approve",
            calldata: [props.spender,
            props.amount.low,
            props.amount.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing approve:", error);
        throw error;
      }
    };



    // Call the `_name` system with the specified Account and calldata
    const _name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "_name",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing _name:", error);
        throw error;
      }
    };



    // Call the `symbol` system with the specified Account and calldata
    const symbol = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "symbol",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing symbol:", error);
        throw error;
      }
    };



    // Call the `decimals` system with the specified Account and calldata
    const decimals = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "decimals",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing decimals:", error);
        throw error;
      }
    };



    // Call the `totalSupply` system with the specified Account and calldata
    const totalSupply = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "totalSupply",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing totalSupply:", error);
        throw error;
      }
    };



    // Call the `balanceOf` system with the specified Account and calldata
    const balanceOf = async (props: { account: Account, address: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "balanceOf",
            calldata: [props.address],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing balanceOf:", error);
        throw error;
      }
    };



    // Call the `transferFrom` system with the specified Account and calldata
    const transferFrom = async (props: { account: Account, sender: bigint, recipient: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transferFrom",
            calldata: [props.sender,
            props.recipient,
            props.amount.low,
            props.amount.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing transferFrom:", error);
        throw error;
      }
    };



    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };



    // Call the `mint` system with the specified Account and calldata
    const mint = async (props: { account: Account, recipient: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "mint",
            calldata: [props.recipient,
            props.amount.low,
            props.amount.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing mint:", error);
        throw error;
      }
    };



    // Call the `faucet` system with the specified Account and calldata
    const faucet = async (props: { account: Account, recipient: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "faucet",
            calldata: [props.recipient],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing faucet:", error);
        throw error;
      }
    };



    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };


    return {
      total_supply, balance_of, allowance, transfer, transfer_from, approve, _name, symbol, decimals, totalSupply, balanceOf, transferFrom, name, mint, faucet, world
    };
  }

  // System definitions for `oz_token-character` contract
  function character() {
    const contract_name = "character";


    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };



    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };



    // Call the `balance_of` system with the specified Account and calldata
    const balance_of = async (props: { account: Account, address: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "balance_of",
            calldata: [props.address],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing balance_of:", error);
        throw error;
      }
    };



    // Call the `owner_of` system with the specified Account and calldata
    const owner_of = async (props: { account: Account, token_id: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "owner_of",
            calldata: [props.token_id.low,
            props.token_id.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing owner_of:", error);
        throw error;
      }
    };



    // Call the `safe_transfer_from` system with the specified Account and calldata
    const safe_transfer_from = async (props: { account: Account, from: bigint, to: bigint, token_id: models.U256, data: bigint[] }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "safe_transfer_from",
            calldata: [props.from,
            props.to,
            props.token_id.low,
            props.token_id.high,
            ...props.data],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing safe_transfer_from:", error);
        throw error;
      }
    };



    // Call the `transfer_from` system with the specified Account and calldata
    const transfer_from = async (props: { account: Account, from: bigint, to: bigint, token_id: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transfer_from",
            calldata: [props.from,
            props.to,
            props.token_id.low,
            props.token_id.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing transfer_from:", error);
        throw error;
      }
    };



    // Call the `approve` system with the specified Account and calldata
    const approve = async (props: { account: Account, to: bigint, token_id: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "approve",
            calldata: [props.to,
            props.token_id.low,
            props.token_id.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing approve:", error);
        throw error;
      }
    };



    // Call the `set_approval_for_all` system with the specified Account and calldata
    const set_approval_for_all = async (props: { account: Account, operator: bigint, approved: boolean }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "set_approval_for_all",
            calldata: [props.operator,
            props.approved],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing set_approval_for_all:", error);
        throw error;
      }
    };



    // Call the `get_approved` system with the specified Account and calldata
    const get_approved = async (props: { account: Account, token_id: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "get_approved",
            calldata: [props.token_id.low,
            props.token_id.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing get_approved:", error);
        throw error;
      }
    };



    // Call the `is_approved_for_all` system with the specified Account and calldata
    const is_approved_for_all = async (props: { account: Account, owner: bigint, operator: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "is_approved_for_all",
            calldata: [props.owner,
            props.operator],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing is_approved_for_all:", error);
        throw error;
      }
    };



    // Call the `supports_interface` system with the specified Account and calldata
    const supports_interface = async (props: { account: Account, interface_id: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "supports_interface",
            calldata: [props.interface_id],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing supports_interface:", error);
        throw error;
      }
    };



    // Call the `_name` system with the specified Account and calldata
    const _name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "_name",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing _name:", error);
        throw error;
      }
    };



    // Call the `symbol` system with the specified Account and calldata
    const symbol = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "symbol",
            calldata: [],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing symbol:", error);
        throw error;
      }
    };



    // Call the `token_uri` system with the specified Account and calldata
    const token_uri = async (props: { account: Account, token_id: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "token_uri",
            calldata: [props.token_id.low,
            props.token_id.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing token_uri:", error);
        throw error;
      }
    };



    // Call the `balanceOf` system with the specified Account and calldata
    const balanceOf = async (props: { account: Account, address: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "balanceOf",
            calldata: [props.address],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing balanceOf:", error);
        throw error;
      }
    };



    // Call the `ownerOf` system with the specified Account and calldata
    const ownerOf = async (props: { account: Account, tokenId: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "ownerOf",
            calldata: [props.tokenId.low,
            props.tokenId.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing ownerOf:", error);
        throw error;
      }
    };



    // Call the `safeTransferFrom` system with the specified Account and calldata
    const safeTransferFrom = async (props: { account: Account, from: bigint, to: bigint, tokenId: models.U256, data: bigint[] }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "safeTransferFrom",
            calldata: [props.from,
            props.to,
            props.tokenId.low,
            props.tokenId.high,
            ...props.data],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing safeTransferFrom:", error);
        throw error;
      }
    };



    // Call the `transferFrom` system with the specified Account and calldata
    const transferFrom = async (props: { account: Account, from: bigint, to: bigint, tokenId: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transferFrom",
            calldata: [props.from,
            props.to,
            props.tokenId.low,
            props.tokenId.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing transferFrom:", error);
        throw error;
      }
    };



    // Call the `setApprovalForAll` system with the specified Account and calldata
    const setApprovalForAll = async (props: { account: Account, operator: bigint, approved: boolean }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "setApprovalForAll",
            calldata: [props.operator,
            props.approved],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing setApprovalForAll:", error);
        throw error;
      }
    };



    // Call the `getApproved` system with the specified Account and calldata
    const getApproved = async (props: { account: Account, tokenId: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "getApproved",
            calldata: [props.tokenId.low,
            props.tokenId.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing getApproved:", error);
        throw error;
      }
    };



    // Call the `isApprovedForAll` system with the specified Account and calldata
    const isApprovedForAll = async (props: { account: Account, owner: bigint, operator: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "isApprovedForAll",
            calldata: [props.owner,
            props.operator],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing isApprovedForAll:", error);
        throw error;
      }
    };



    // Call the `tokenURI` system with the specified Account and calldata
    const tokenURI = async (props: { account: Account, tokenId: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "tokenURI",
            calldata: [props.tokenId.low,
            props.tokenId.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing tokenURI:", error);
        throw error;
      }
    };



    // Call the `mint` system with the specified Account and calldata
    const mint = async (props: { account: Account, recipient: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "mint",
            calldata: [props.recipient],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing mint:", error);
        throw error;
      }
    };



    // Call the `render_uri` system with the specified Account and calldata
    const render_uri = async (props: { account: Account, token_id: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "render_uri",
            calldata: [props.token_id.low,
            props.token_id.high],
          },
          "oz_token"
        );
      } catch (error) {
        console.error("Error executing render_uri:", error);
        throw error;
      }
    };


    return {
      name, world, balance_of, owner_of, safe_transfer_from, transfer_from, approve, set_approval_for_all, get_approved, is_approved_for_all, supports_interface, _name, symbol, token_uri, balanceOf, ownerOf, safeTransferFrom, transferFrom, setApprovalForAll, getApproved, isApprovedForAll, tokenURI, mint, render_uri
    };
  }

  return {
    actions: actions(),
    cash: cash(),
    character: character()
  };
}
