
// Generated by dojo-bindgen on Wed, 16 Oct 2024 18:02:22 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript` 
import { Account, byteArray } from "starknet";
import { DojoProvider } from "@dojoengine/core";
import * as models from "./models.gen";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
    // System definitions for `oz_token-actions` contract
    function actions() {
        const contract_name = "actions";

        
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "world",
                        calldata: [],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing world:", error);
                throw error;
            }
        };
            

    
        // Call the `name` system with the specified Account and calldata
        const name = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "name",
                        calldata: [],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing name:", error);
                throw error;
            }
        };
            

    
        // Call the `spawn` system with the specified Account and calldata
        const spawn = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "spawn",
                        calldata: [],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing spawn:", error);
                throw error;
            }
        };
            

    
        // Call the `move` system with the specified Account and calldata
        const move = async (props: { account: Account, direction: models.Direction }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "move",
                        calldata: [["None", "Left", "Right", "Up", "Down"].indexOf(props.direction.type)],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing move:", error);
                throw error;
            }
        };
            

        return {
            world, name, spawn, move
        };
    }

    // System definitions for `oz_token-character` contract
    function character() {
        const contract_name = "character";

        
        // Call the `balance_of` system with the specified Account and calldata
        const balance_of = async (props: { account: Account, account: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "balance_of",
                        calldata: [props.account],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing balance_of:", error);
                throw error;
            }
        };
            

    
        // Call the `owner_of` system with the specified Account and calldata
        const owner_of = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "owner_of",
                        calldata: [props.token_id],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing owner_of:", error);
                throw error;
            }
        };
            

    
        // Call the `safe_transfer_from` system with the specified Account and calldata
        const safe_transfer_from = async (props: { account: Account, from: bigint, to: bigint, token_id: models.U256, data: RecsType.BigIntArray }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "safe_transfer_from",
                        calldata: [props.from,
                props.to,
                props.token_id,
                ...props.data],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing safe_transfer_from:", error);
                throw error;
            }
        };
            

    
        // Call the `transfer_from` system with the specified Account and calldata
        const transfer_from = async (props: { account: Account, from: bigint, to: bigint, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "transfer_from",
                        calldata: [props.from,
                props.to,
                props.token_id],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing transfer_from:", error);
                throw error;
            }
        };
            

    
        // Call the `approve` system with the specified Account and calldata
        const approve = async (props: { account: Account, to: bigint, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "approve",
                        calldata: [props.to,
                props.token_id],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing approve:", error);
                throw error;
            }
        };
            

    
        // Call the `set_approval_for_all` system with the specified Account and calldata
        const set_approval_for_all = async (props: { account: Account, operator: bigint, approved: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "set_approval_for_all",
                        calldata: [props.operator,
                props.approved],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing set_approval_for_all:", error);
                throw error;
            }
        };
            

    
        // Call the `get_approved` system with the specified Account and calldata
        const get_approved = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "get_approved",
                        calldata: [props.token_id],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing get_approved:", error);
                throw error;
            }
        };
            

    
        // Call the `is_approved_for_all` system with the specified Account and calldata
        const is_approved_for_all = async (props: { account: Account, owner: bigint, operator: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "is_approved_for_all",
                        calldata: [props.owner,
                props.operator],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing is_approved_for_all:", error);
                throw error;
            }
        };
            

    
        // Call the `supports_interface` system with the specified Account and calldata
        const supports_interface = async (props: { account: Account, interface_id: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "supports_interface",
                        calldata: [props.interface_id],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing supports_interface:", error);
                throw error;
            }
        };
            

    
        // Call the `_name` system with the specified Account and calldata
        const _name = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "_name",
                        calldata: [],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing _name:", error);
                throw error;
            }
        };
            

    
        // Call the `symbol` system with the specified Account and calldata
        const symbol = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "symbol",
                        calldata: [],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing symbol:", error);
                throw error;
            }
        };
            

    
        // Call the `token_uri` system with the specified Account and calldata
        const token_uri = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "token_uri",
                        calldata: [props.token_id],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing token_uri:", error);
                throw error;
            }
        };
            

    
        // Call the `balanceOf` system with the specified Account and calldata
        const balanceOf = async (props: { account: Account, account: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "balanceOf",
                        calldata: [props.account],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing balanceOf:", error);
                throw error;
            }
        };
            

    
        // Call the `ownerOf` system with the specified Account and calldata
        const ownerOf = async (props: { account: Account, tokenId: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "ownerOf",
                        calldata: [props.tokenId],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing ownerOf:", error);
                throw error;
            }
        };
            

    
        // Call the `safeTransferFrom` system with the specified Account and calldata
        const safeTransferFrom = async (props: { account: Account, from: bigint, to: bigint, tokenId: models.U256, data: RecsType.BigIntArray }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "safeTransferFrom",
                        calldata: [props.from,
                props.to,
                props.tokenId,
                ...props.data],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing safeTransferFrom:", error);
                throw error;
            }
        };
            

    
        // Call the `transferFrom` system with the specified Account and calldata
        const transferFrom = async (props: { account: Account, from: bigint, to: bigint, tokenId: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "transferFrom",
                        calldata: [props.from,
                props.to,
                props.tokenId],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing transferFrom:", error);
                throw error;
            }
        };
            

    
        // Call the `setApprovalForAll` system with the specified Account and calldata
        const setApprovalForAll = async (props: { account: Account, operator: bigint, approved: boolean }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "setApprovalForAll",
                        calldata: [props.operator,
                props.approved],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing setApprovalForAll:", error);
                throw error;
            }
        };
            

    
        // Call the `getApproved` system with the specified Account and calldata
        const getApproved = async (props: { account: Account, tokenId: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "getApproved",
                        calldata: [props.tokenId],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing getApproved:", error);
                throw error;
            }
        };
            

    
        // Call the `isApprovedForAll` system with the specified Account and calldata
        const isApprovedForAll = async (props: { account: Account, owner: bigint, operator: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "isApprovedForAll",
                        calldata: [props.owner,
                props.operator],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing isApprovedForAll:", error);
                throw error;
            }
        };
            

    
        // Call the `tokenURI` system with the specified Account and calldata
        const tokenURI = async (props: { account: Account, tokenId: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "tokenURI",
                        calldata: [props.tokenId],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing tokenURI:", error);
                throw error;
            }
        };
            

    
        // Call the `mint` system with the specified Account and calldata
        const mint = async (props: { account: Account, recipient: bigint }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "mint",
                        calldata: [props.recipient],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing mint:", error);
                throw error;
            }
        };
            

    
        // Call the `render_uri` system with the specified Account and calldata
        const render_uri = async (props: { account: Account, token_id: models.U256 }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "render_uri",
                        calldata: [props.token_id],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing render_uri:", error);
                throw error;
            }
        };
            

    
        // Call the `name` system with the specified Account and calldata
        const name = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "name",
                        calldata: [],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing name:", error);
                throw error;
            }
        };
            

    
        // Call the `world` system with the specified Account and calldata
        const world = async (props: { account: Account }) => {
            try {
                return await provider.execute(
                    props.account,
                    {
                        contractName: contract_name,
                        entrypoint: "world",
                        calldata: [],
                    },
                    "oz_token"
                );
            } catch (error) {
                console.error("Error executing world:", error);
                throw error;
            }
        };
            

        return {
            balance_of, owner_of, safe_transfer_from, transfer_from, approve, set_approval_for_all, get_approved, is_approved_for_all, supports_interface, _name, symbol, token_uri, balanceOf, ownerOf, safeTransferFrom, transferFrom, setApprovalForAll, getApproved, isApprovedForAll, tokenURI, mint, render_uri, name, world
        };
    }

    return {
        actions: actions(),
        character: character()
    };
}
