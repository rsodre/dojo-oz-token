// Generated by dojo-bindgen on Wed, 16 Oct 2024 04:22:46 +0000. Do not modify this file manually.
import { Account } from "starknet";
import {
    Clause,
    Client,
    ModelClause,
    createClient,
    valueToToriiValueAndOperator,
} from "@dojoengine/torii-client";
import {
    LOCAL_KATANA,
    LOCAL_RELAY,
    LOCAL_TORII,
    createManifestFromJson,
} from "@dojoengine/core";

// Type definition for `core::byte_array::ByteArray` struct
export interface ByteArray {
    data: string[];
    pending_word: string;
    pending_word_len: number;
}

// Type definition for `oz_token::models::token_config::TokenConfig` struct
export interface TokenConfig {
    token_address: string;
    minter_contract: string;
    minted_count: bigint;
}

// Type definition for `dojo::model::layout::FieldLayout` struct
export interface FieldLayout {
    selector: string;
    layout: Layout;
}

// Type definition for `dojo::model::layout::Layout` enum
type Layout = { type: 'Fixed'; data: number[]; } | { type: 'Struct'; data: FieldLayout[]; } | { type: 'Tuple'; data: Layout[]; } | { type: 'Array'; data: Layout[]; } | { type: 'ByteArray'; } | { type: 'Enum'; data: FieldLayout[]; }
// Type definition for `core::option::Option::<core::integer::u32>` enum
type Option<A> = { type: 'Some'; data: A; } | { type: 'None'; }

// Type definition for `oz_token::models::starter::Moves` struct
export interface Moves {
    player: string;
    remaining: number;
    last_direction: Direction;
    can_move: boolean;
}

// Type definition for `oz_token::models::starter::Direction` enum
type Direction = { type: 'None'; } | { type: 'Left'; } | { type: 'Right'; } | { type: 'Up'; } | { type: 'Down'; }

// Type definition for `oz_token::systems::actions::actions::Moved` struct
export interface Moved {
    player: string;
    direction: Direction;
}


// Type definition for `oz_token::models::starter::Vec2` struct
export interface Vec2 {
    x: number;
    y: number;
}

// Type definition for `oz_token::models::starter::Position` struct
export interface Position {
    player: string;
    vec: Vec2;
}


// Type definition for `oz_token::models::starter::DirectionsAvailable` struct
export interface DirectionsAvailable {
    player: string;
    directions: Direction[];
}


class BaseCalls {
    contractAddress: string;
    account?: Account;

    constructor(contractAddress: string, account?: Account) {
        this.account = account;
        this.contractAddress = contractAddress;
    }

    async execute(entrypoint: string, calldata: any[] = []): Promise<void> {
        if (!this.account) {
            throw new Error("No account set to interact with dojo_starter");
        }

        await this.account.execute(
            {
                contractAddress: this.contractAddress,
                entrypoint,
                calldata,
            },
            undefined,
            {
                maxFee: 0,
            }
        );
    }
}

class ActionsCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async spawn(): Promise<void> {
        try {
            await this.execute("spawn", [])
        } catch (error) {
            console.error("Error executing spawn:", error);
            throw error;
        }
    }

    async move(direction: Direction): Promise<void> {
        try {
            await this.execute("move", [direction])
        } catch (error) {
            console.error("Error executing move:", error);
            throw error;
        }
    }
}
class CharacterCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }

    async mint(recipient: string): Promise<void> {
        try {
            await this.execute("mint", [recipient])
        } catch (error) {
            console.error("Error executing mint:", error);
            throw error;
        }
    }

    async renderUri(token_id: U256): Promise<void> {
        try {
            await this.execute("render_uri", [token_id])
        } catch (error) {
            console.error("Error executing renderUri:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balance_of", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(token_id: U256): Promise<void> {
        try {
            await this.execute("owner_of", [token_id])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, token_id: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safe_transfer_from", [from,
                to,
                token_id,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("transfer_from", [from,
                to,
                token_id])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async approve(to: string, token_id: U256): Promise<void> {
        try {
            await this.execute("approve", [to,
                token_id])
        } catch (error) {
            console.error("Error executing approve:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("set_approval_for_all", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(token_id: U256): Promise<void> {
        try {
            await this.execute("get_approved", [token_id])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("is_approved_for_all", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async supportsInterface(interface_id: string): Promise<void> {
        try {
            await this.execute("supports_interface", [interface_id])
        } catch (error) {
            console.error("Error executing supportsInterface:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("_name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async symbol(): Promise<void> {
        try {
            await this.execute("symbol", [])
        } catch (error) {
            console.error("Error executing symbol:", error);
            throw error;
        }
    }

    async tokenUri(token_id: U256): Promise<void> {
        try {
            await this.execute("token_uri", [token_id])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async balanceOf(account: string): Promise<void> {
        try {
            await this.execute("balanceOf", [account])
        } catch (error) {
            console.error("Error executing balanceOf:", error);
            throw error;
        }
    }

    async ownerOf(tokenId: U256): Promise<void> {
        try {
            await this.execute("ownerOf", [tokenId])
        } catch (error) {
            console.error("Error executing ownerOf:", error);
            throw error;
        }
    }

    async safeTransferFrom(from: string, to: string, tokenId: U256, data: string[]): Promise<void> {
        try {
            await this.execute("safeTransferFrom", [from,
                to,
                tokenId,
                data])
        } catch (error) {
            console.error("Error executing safeTransferFrom:", error);
            throw error;
        }
    }

    async transferFrom(from: string, to: string, tokenId: U256): Promise<void> {
        try {
            await this.execute("transferFrom", [from,
                to,
                tokenId])
        } catch (error) {
            console.error("Error executing transferFrom:", error);
            throw error;
        }
    }

    async setApprovalForAll(operator: string, approved: boolean): Promise<void> {
        try {
            await this.execute("setApprovalForAll", [operator,
                approved])
        } catch (error) {
            console.error("Error executing setApprovalForAll:", error);
            throw error;
        }
    }

    async getApproved(tokenId: U256): Promise<void> {
        try {
            await this.execute("getApproved", [tokenId])
        } catch (error) {
            console.error("Error executing getApproved:", error);
            throw error;
        }
    }

    async isApprovedForAll(owner: string, operator: string): Promise<void> {
        try {
            await this.execute("isApprovedForAll", [owner,
                operator])
        } catch (error) {
            console.error("Error executing isApprovedForAll:", error);
            throw error;
        }
    }

    async tokenUri(tokenId: U256): Promise<void> {
        try {
            await this.execute("tokenURI", [tokenId])
        } catch (error) {
            console.error("Error executing tokenUri:", error);
            throw error;
        }
    }

    async world(): Promise<void> {
        try {
            await this.execute("world", [])
        } catch (error) {
            console.error("Error executing world:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async name(): Promise<void> {
        try {
            await this.execute("name", [])
        } catch (error) {
            console.error("Error executing name:", error);
            throw error;
        }
    }

    async namespace(): Promise<void> {
        try {
            await this.execute("namespace", [])
        } catch (error) {
            console.error("Error executing namespace:", error);
            throw error;
        }
    }

    async tag(): Promise<void> {
        try {
            await this.execute("tag", [])
        } catch (error) {
            console.error("Error executing tag:", error);
            throw error;
        }
    }

    async nameHash(): Promise<void> {
        try {
            await this.execute("name_hash", [])
        } catch (error) {
            console.error("Error executing nameHash:", error);
            throw error;
        }
    }

    async namespaceHash(): Promise<void> {
        try {
            await this.execute("namespace_hash", [])
        } catch (error) {
            console.error("Error executing namespaceHash:", error);
            throw error;
        }
    }

    async selector(): Promise<void> {
        try {
            await this.execute("selector", [])
        } catch (error) {
            console.error("Error executing selector:", error);
            throw error;
        }
    }
}

type Query = Partial<{
    TokenConfig: ModelClause<TokenConfig>;
    Moves: ModelClause<Moves>;
    Moved: ModelClause<Moved>;
    Position: ModelClause<Position>;
    DirectionsAvailable: ModelClause<DirectionsAvailable>;
}>;

type ResultMapping = {
    TokenConfig: TokenConfig;
    Moves: Moves;
    Moved: Moved;
    Position: Position;
    DirectionsAvailable: DirectionsAvailable;
};

type QueryResult<T extends Query> = {
    [K in keyof T]: K extends keyof ResultMapping ? ResultMapping[K] : never;
};

// Only supports a single model for now, since torii doesn't support multiple models
// And inside that single model, there's only support for a single query.
function convertQueryToToriiClause(query: Query): Clause | undefined {
    const [model, clause] = Object.entries(query)[0];

    if (Object.keys(clause).length === 0) {
        return undefined;
    }

    const clauses: Clause[] = Object.entries(clause).map(([key, value]) => {
        return {
            Member: {
                model,
                member: key,
                ...valueToToriiValueAndOperator(value),
            },
        } satisfies Clause;
    });

    return clauses[0];
}
type GeneralParams = {
    toriiUrl?: string;
    relayUrl?: string;
    account?: Account;
};

type InitialParams = GeneralParams &
    (
        | {
                rpcUrl?: string;
                worldAddress: string;
                actionsAddress: string;
    characterAddress: string;
            }
        | {
                manifest: any;
            }
    );

export class OzToken {
    rpcUrl: string;
    toriiUrl: string;
    toriiPromise: Promise<Client>;
    relayUrl: string;
    worldAddress: string;
    private _account?: Account;
    actions: ActionsCalls;
    actionsAddress: string;
    character: CharacterCalls;
    characterAddress: string;

    constructor(params: InitialParams) {
        if ("manifest" in params) {
            const config = createManifestFromJson(params.manifest);
            this.rpcUrl = config.world.metadata.rpc_url;
            this.worldAddress = config.world.address;

            const actionsAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::actions::actions"
            )?.address;

            if (!actionsAddress) {
                throw new Error("No actions contract found in the manifest");
            }

            this.actionsAddress = actionsAddress;
    const characterAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::character::character"
            )?.address;

            if (!characterAddress) {
                throw new Error("No character contract found in the manifest");
            }

            this.characterAddress = characterAddress;
        } else {
            this.rpcUrl = params.rpcUrl || LOCAL_KATANA;
            this.worldAddress = params.worldAddress;
            this.actionsAddress = params.actionsAddress;
    this.characterAddress = params.characterAddress;
        }
        this.toriiUrl = params.toriiUrl || LOCAL_TORII;
        this.relayUrl = params.relayUrl || LOCAL_RELAY;
        this._account = params.account;
        this.actions = new ActionsCalls(this.actionsAddress, this._account);
    this.character = new CharacterCalls(this.characterAddress, this._account);

        this.toriiPromise = createClient([], {
            rpcUrl: this.rpcUrl,
            toriiUrl: this.toriiUrl,
            worldAddress: this.worldAddress,
            relayUrl: this.relayUrl,
        });
    }

    get account(): Account | undefined {
        return this._account;
    }

    set account(account: Account) {
        this._account = account;
        this.actions = new ActionsCalls(this.actionsAddress, this._account);
    this.character = new CharacterCalls(this.characterAddress, this._account);
    }

    async query<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        return {
            torii,
            findEntities: async () => this.findEntities(query, limit, offset),
        };
    }

    async findEntities<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        const clause = convertQueryToToriiClause(query);

        const toriiResult = await torii.getEntities({
            limit,
            offset,
            clause,
        });

        return toriiResult as Record<string, QueryResult<T>>;
    }

    async findEntity<T extends Query>(query: T) {
        const result = await this.findEntities(query, 1);

        if (Object.values(result).length === 0) {
            return undefined;
        }

        return Object.values(result)[0] as QueryResult<T>;
    }
}