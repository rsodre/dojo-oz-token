schema {
  query: World__Query
  subscription: World__Subscription
}

scalar ContractAddress

scalar Cursor

scalar DateTime

type ERC__Balance {
  balance: String!
  type: String!
  tokenMetadata: ERC__Token!
}

type ERC__Token {
  name: String!
  symbol: String!
  tokenId: String!
  decimals: String!
  contractAddress: String!
}

type ERC__Transfer {
  from: String!
  to: String!
  amount: String!
  type: String!
  executedAt: String!
  tokenMetadata: ERC__Token!
  transactionHash: String!
}

scalar Enum

union ModelUnion =
    oz_token_CoinConfig
  | oz_token_DirectionsAvailable
  | oz_token_Moved
  | oz_token_Moves
  | oz_token_Position
  | oz_token_TokenConfig

enum OrderDirection {
  ASC
  DESC
}

type World__Content {
  name: String
  description: String
  website: String
  iconUri: String
  coverUri: String
  socials: [World__Social]
}

type World__Entity {
  id: ID
  keys: [String]
  eventId: String
  executedAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  models: [ModelUnion]
}

type World__EntityConnection {
  edges: [World__EntityEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type World__EntityEdge {
  node: World__Entity
  cursor: Cursor
}

type World__Event {
  id: ID
  keys: [String]
  data: [String]
  executedAt: DateTime
  createdAt: DateTime
  transactionHash: String
}

type World__EventConnection {
  edges: [World__EventEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type World__EventEdge {
  node: World__Event
  cursor: Cursor
}

type World__EventMessage {
  id: ID
  keys: [String]
  eventId: String
  executedAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  models: [ModelUnion]
}

type World__EventMessageConnection {
  edges: [World__EventMessageEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type World__EventMessageEdge {
  node: World__EventMessage
  cursor: Cursor
}

type World__Metadata {
  id: ID
  uri: String
  worldAddress: String!
  content: World__Content
  iconImg: String
  coverImg: String
  executedAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

type World__MetadataConnection {
  edges: [World__MetadataEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type World__MetadataEdge {
  node: World__Metadata
  cursor: Cursor
}

type World__Model {
  id: ID
  name: String
  namespace: String
  classHash: felt252
  contractAddress: felt252
  transactionHash: felt252
  executedAt: DateTime
  createdAt: DateTime
}

type World__ModelConnection {
  edges: [World__ModelEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type World__ModelEdge {
  node: World__Model
  cursor: Cursor
}

input World__ModelOrder {
  direction: OrderDirection!
  field: World__ModelOrderField!
}

enum World__ModelOrderField {
  NAME
  CLASS_HASH
}

type World__PageInfo {
  hasPreviousPage: Boolean
  hasNextPage: Boolean
  startCursor: Cursor
  endCursor: Cursor
}

type World__Query {
  entity(id: ID!): World__Entity!
  entities(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    keys: [String]
  ): World__EntityConnection
  eventMessage(id: ID!): World__EventMessage!
  eventMessages(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    keys: [String]
  ): World__EventMessageConnection
  events(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    keys: [String]
  ): World__EventConnection
  metadatas(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
  ): World__MetadataConnection
  model(id: ID!): World__Model!
  models(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    order: World__ModelOrder
  ): World__ModelConnection
  transaction(transactionHash: ID!): World__Transaction!
  transactions(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
  ): World__TransactionConnection
  ercBalance(accountAddress: String!): [ERC__Balance]
  ercTransfer(accountAddress: String!, limit: Int!): [ERC__Transfer]
  ozTokenCoinConfigModels(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    where: oz_token_CoinConfigWhereInput
    order: oz_token_CoinConfigOrder
  ): oz_token_CoinConfigConnection
  ozTokenDirectionsAvailableModels(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    where: oz_token_DirectionsAvailableWhereInput
    order: oz_token_DirectionsAvailableOrder
  ): oz_token_DirectionsAvailableConnection
  ozTokenMovedModels(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    where: oz_token_MovedWhereInput
    order: oz_token_MovedOrder
  ): oz_token_MovedConnection
  ozTokenMovesModels(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    where: oz_token_MovesWhereInput
    order: oz_token_MovesOrder
  ): oz_token_MovesConnection
  ozTokenPositionModels(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    where: oz_token_PositionWhereInput
    order: oz_token_PositionOrder
  ): oz_token_PositionConnection
  ozTokenTokenConfigModels(
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    offset: Int
    limit: Int
    where: oz_token_TokenConfigWhereInput
    order: oz_token_TokenConfigOrder
  ): oz_token_TokenConfigConnection
}

type World__Social {
  name: String
  url: String
}

type World__Subscription {
  entityUpdated(id: ID): World__Entity!
  eventMessageUpdated(id: ID): World__EventMessage!
  eventEmitted(keys: [String]): World__Event!
  modelRegistered(id: ID): World__Model!
}

type World__Transaction {
  id: ID
  transactionHash: felt252
  senderAddress: felt252
  calldata: [felt252]
  maxFee: felt252
  signature: [felt252]
  nonce: felt252
  executedAt: DateTime
  createdAt: DateTime
}

type World__TransactionConnection {
  edges: [World__TransactionEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type World__TransactionEdge {
  node: World__Transaction
  cursor: Cursor
}

scalar bool

scalar felt252

type oz_token_CoinConfig {
  coin_address: ContractAddress
  minter_contract_address: ContractAddress
  faucet_amount: u256
  entity: World__Entity
  eventMessage: World__EventMessage
}

type oz_token_CoinConfigConnection {
  edges: [oz_token_CoinConfigEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type oz_token_CoinConfigEdge {
  node: oz_token_CoinConfig
  cursor: Cursor
}

input oz_token_CoinConfigOrder {
  direction: OrderDirection!
  field: oz_token_CoinConfigOrderField!
}

enum oz_token_CoinConfigOrderField {
  COIN_ADDRESS
  MINTER_CONTRACT_ADDRESS
  FAUCET_AMOUNT
}

input oz_token_CoinConfigWhereInput {
  coin_address: ContractAddress
  coin_addressGT: ContractAddress
  coin_addressGTE: ContractAddress
  coin_addressLT: ContractAddress
  coin_addressLTE: ContractAddress
  coin_addressNEQ: ContractAddress
  coin_addressEQ: ContractAddress
  coin_addressNOTIN: [ContractAddress]
  coin_addressIN: [ContractAddress]
  coin_addressNOTLIKE: ContractAddress
  coin_addressLIKE: ContractAddress
  minter_contract_address: ContractAddress
  minter_contract_addressGT: ContractAddress
  minter_contract_addressGTE: ContractAddress
  minter_contract_addressLT: ContractAddress
  minter_contract_addressLTE: ContractAddress
  minter_contract_addressNEQ: ContractAddress
  minter_contract_addressEQ: ContractAddress
  minter_contract_addressNOTIN: [ContractAddress]
  minter_contract_addressIN: [ContractAddress]
  minter_contract_addressNOTLIKE: ContractAddress
  minter_contract_addressLIKE: ContractAddress
  faucet_amount: u256
  faucet_amountGT: u256
  faucet_amountGTE: u256
  faucet_amountLT: u256
  faucet_amountLTE: u256
  faucet_amountNEQ: u256
  faucet_amountEQ: u256
  faucet_amountNOTIN: [u256]
  faucet_amountIN: [u256]
  faucet_amountNOTLIKE: u256
  faucet_amountLIKE: u256
}

type oz_token_DirectionsAvailable {
  player: ContractAddress
  directions: [Enum]
  entity: World__Entity
  eventMessage: World__EventMessage
}

type oz_token_DirectionsAvailableConnection {
  edges: [oz_token_DirectionsAvailableEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type oz_token_DirectionsAvailableEdge {
  node: oz_token_DirectionsAvailable
  cursor: Cursor
}

input oz_token_DirectionsAvailableOrder {
  direction: OrderDirection!
  field: oz_token_DirectionsAvailableOrderField!
}

enum oz_token_DirectionsAvailableOrderField {
  PLAYER
  DIRECTIONS
}

input oz_token_DirectionsAvailableWhereInput {
  player: ContractAddress
  playerGT: ContractAddress
  playerGTE: ContractAddress
  playerLT: ContractAddress
  playerLTE: ContractAddress
  playerNEQ: ContractAddress
  playerEQ: ContractAddress
  playerNOTIN: [ContractAddress]
  playerIN: [ContractAddress]
  playerNOTLIKE: ContractAddress
  playerLIKE: ContractAddress
}

type oz_token_Moved {
  player: ContractAddress
  direction: Enum
  entity: World__Entity
  eventMessage: World__EventMessage
}

type oz_token_MovedConnection {
  edges: [oz_token_MovedEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type oz_token_MovedEdge {
  node: oz_token_Moved
  cursor: Cursor
}

input oz_token_MovedOrder {
  direction: OrderDirection!
  field: oz_token_MovedOrderField!
}

enum oz_token_MovedOrderField {
  PLAYER
  DIRECTION
}

input oz_token_MovedWhereInput {
  player: ContractAddress
  playerGT: ContractAddress
  playerGTE: ContractAddress
  playerLT: ContractAddress
  playerLTE: ContractAddress
  playerNEQ: ContractAddress
  playerEQ: ContractAddress
  playerNOTIN: [ContractAddress]
  playerIN: [ContractAddress]
  playerNOTLIKE: ContractAddress
  playerLIKE: ContractAddress
  direction: Enum
}

type oz_token_Moves {
  player: ContractAddress
  remaining: u8
  last_direction: Enum
  can_move: bool
  entity: World__Entity
  eventMessage: World__EventMessage
}

type oz_token_MovesConnection {
  edges: [oz_token_MovesEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type oz_token_MovesEdge {
  node: oz_token_Moves
  cursor: Cursor
}

input oz_token_MovesOrder {
  direction: OrderDirection!
  field: oz_token_MovesOrderField!
}

enum oz_token_MovesOrderField {
  PLAYER
  REMAINING
  LAST_DIRECTION
  CAN_MOVE
}

input oz_token_MovesWhereInput {
  player: ContractAddress
  playerGT: ContractAddress
  playerGTE: ContractAddress
  playerLT: ContractAddress
  playerLTE: ContractAddress
  playerNEQ: ContractAddress
  playerEQ: ContractAddress
  playerNOTIN: [ContractAddress]
  playerIN: [ContractAddress]
  playerNOTLIKE: ContractAddress
  playerLIKE: ContractAddress
  remaining: u8
  remainingGT: u8
  remainingGTE: u8
  remainingLT: u8
  remainingLTE: u8
  remainingNEQ: u8
  remainingEQ: u8
  remainingNOTIN: [u8]
  remainingIN: [u8]
  remainingNOTLIKE: u8
  remainingLIKE: u8
  last_direction: Enum
  can_move: bool
}

type oz_token_Position {
  player: ContractAddress
  vec: oz_token_Position_Vec2
  entity: World__Entity
  eventMessage: World__EventMessage
}

type oz_token_PositionConnection {
  edges: [oz_token_PositionEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type oz_token_PositionEdge {
  node: oz_token_Position
  cursor: Cursor
}

input oz_token_PositionOrder {
  direction: OrderDirection!
  field: oz_token_PositionOrderField!
}

enum oz_token_PositionOrderField {
  PLAYER
  VEC
}

input oz_token_PositionWhereInput {
  player: ContractAddress
  playerGT: ContractAddress
  playerGTE: ContractAddress
  playerLT: ContractAddress
  playerLTE: ContractAddress
  playerNEQ: ContractAddress
  playerEQ: ContractAddress
  playerNOTIN: [ContractAddress]
  playerIN: [ContractAddress]
  playerNOTLIKE: ContractAddress
  playerLIKE: ContractAddress
}

type oz_token_Position_Vec2 {
  x: u32
  y: u32
}

type oz_token_TokenConfig {
  token_address: ContractAddress
  minter_contract_address: ContractAddress
  minted_count: u256
  entity: World__Entity
  eventMessage: World__EventMessage
}

type oz_token_TokenConfigConnection {
  edges: [oz_token_TokenConfigEdge]
  totalCount: Int!
  pageInfo: World__PageInfo!
}

type oz_token_TokenConfigEdge {
  node: oz_token_TokenConfig
  cursor: Cursor
}

input oz_token_TokenConfigOrder {
  direction: OrderDirection!
  field: oz_token_TokenConfigOrderField!
}

enum oz_token_TokenConfigOrderField {
  TOKEN_ADDRESS
  MINTER_CONTRACT_ADDRESS
  MINTED_COUNT
}

input oz_token_TokenConfigWhereInput {
  token_address: ContractAddress
  token_addressGT: ContractAddress
  token_addressGTE: ContractAddress
  token_addressLT: ContractAddress
  token_addressLTE: ContractAddress
  token_addressNEQ: ContractAddress
  token_addressEQ: ContractAddress
  token_addressNOTIN: [ContractAddress]
  token_addressIN: [ContractAddress]
  token_addressNOTLIKE: ContractAddress
  token_addressLIKE: ContractAddress
  minter_contract_address: ContractAddress
  minter_contract_addressGT: ContractAddress
  minter_contract_addressGTE: ContractAddress
  minter_contract_addressLT: ContractAddress
  minter_contract_addressLTE: ContractAddress
  minter_contract_addressNEQ: ContractAddress
  minter_contract_addressEQ: ContractAddress
  minter_contract_addressNOTIN: [ContractAddress]
  minter_contract_addressIN: [ContractAddress]
  minter_contract_addressNOTLIKE: ContractAddress
  minter_contract_addressLIKE: ContractAddress
  minted_count: u256
  minted_countGT: u256
  minted_countGTE: u256
  minted_countLT: u256
  minted_countLTE: u256
  minted_countNEQ: u256
  minted_countEQ: u256
  minted_countNOTIN: [u256]
  minted_countIN: [u256]
  minted_countNOTLIKE: u256
  minted_countLIKE: u256
}

scalar u256

scalar u32

scalar u8
